/* This file is autogenerated. DO NOT CHANGE. All changes will be lost */


#include "message.qpb.h"

#include <QtProtobuf/qprotobufregistration.h>

#include <cmath>

namespace chat {

class Login_QtProtobufData : public QSharedData
{
public:
    Login_QtProtobufData()
        : QSharedData(),
          m_time(0),
          m_typeID(0)
    {
    }

    Login_QtProtobufData(const Login_QtProtobufData &other)
        : QSharedData(other),
          m_name(other.m_name),
          m_time(other.m_time),
          m_typeID(other.m_typeID)
    {
    }

    QString m_name;
    QtProtobuf::int64 m_time;
    QtProtobuf::int64 m_typeID;
};

Login::~Login() = default;

static constexpr struct {
    QtProtobufPrivate::QProtobufPropertyOrdering::Data data;
    const std::array<uint, 13> qt_protobuf_Login_uint_data;
    const char qt_protobuf_Login_char_data[29];
} qt_protobuf_Login_metadata {
    // data
    {
        0, /* = version */
        3, /* = num fields */
        4, /* = field number offset */
        7, /* = property index offset */
        10, /* = field flags offset */
        10, /* = message full name length */
    },
    // uint_data
    {
        // JSON name offsets:
        11, /* = name */
        16, /* = time */
        21, /* = typeID */
        28, /* = end-of-string-marker */
        // Field numbers:
        1, /* = name */
        2, /* = time */
        3, /* = typeID */
        // Property indices:
        0, /* = name */
        1, /* = time */
        2, /* = typeID */
        // Field flags:
        uint(QtProtobufPrivate::FieldFlag::NoFlags), /* = name */
        uint(QtProtobufPrivate::FieldFlag::NoFlags), /* = time */
        uint(QtProtobufPrivate::FieldFlag::NoFlags), /* = typeID */
    },
    // char_data
    /* metadata char_data: */
    "chat.Login\0" /* = full message name */
    /* field char_data: */
    "name\0time\0typeID\0"
};

const QtProtobufPrivate::QProtobufPropertyOrdering Login::staticPropertyOrdering = {
    &qt_protobuf_Login_metadata.data
};

void Login::registerTypes()
{
    qRegisterMetaType<Login>();
    qRegisterMetaType<QList<Login>>();
}

Login::Login()
    : QProtobufMessage(&Login::staticMetaObject, &Login::staticPropertyOrdering),
      dptr(new Login_QtProtobufData)
{
}

Login::Login(const Login &other)
    = default;
Login &Login::operator =(const Login &other)
{
    Login temp(other);
    swap(temp);
    return *this;
}
Login::Login(Login &&other) noexcept
    = default;
Login::operator QVariant() const
{
    return QVariant::fromValue(*this);
}
bool comparesEqual(const Login &lhs, const Login &rhs) noexcept
{
    return operator ==(static_cast<const QProtobufMessage&>(lhs),
                       static_cast<const QProtobufMessage&>(rhs))
        && lhs.dptr->m_name == rhs.dptr->m_name
        && lhs.dptr->m_time == rhs.dptr->m_time
        && lhs.dptr->m_typeID == rhs.dptr->m_typeID;
}

const QString &Login::name() const &
{
    return dptr->m_name;
}

QtProtobuf::int64 Login::time() const
{
    return dptr->m_time;
}

QtProtobuf::int64 Login::typeID() const
{
    return dptr->m_typeID;
}

void Login::setName(const QString &name)
{
    if (dptr->m_name != name) {
        dptr.detach();
        dptr->m_name = name;
    }
}

void Login::setName(QString &&name)
{
    if (dptr->m_name != name) {
        dptr.detach();
        dptr->m_name = std::move(name);
    }
}

void Login::setTime(QtProtobuf::int64 time)
{
    if (dptr->m_time != time) {
        dptr.detach();
        dptr->m_time = time;
    }
}

void Login::setTypeID(QtProtobuf::int64 typeID)
{
    if (dptr->m_typeID != typeID) {
        dptr.detach();
        dptr->m_typeID = typeID;
    }
}


class Sensor_QtProtobufData : public QSharedData
{
public:
    Sensor_QtProtobufData()
        : QSharedData(),
          m_value(0),
          m_typeID(0)
    {
    }

    Sensor_QtProtobufData(const Sensor_QtProtobufData &other)
        : QSharedData(other),
          m_iD(other.m_iD),
          m_value(other.m_value),
          m_typeID(other.m_typeID)
    {
    }

    QString m_iD;
    QtProtobuf::int64 m_value;
    QtProtobuf::int64 m_typeID;
};

Sensor::~Sensor() = default;

static constexpr struct {
    QtProtobufPrivate::QProtobufPropertyOrdering::Data data;
    const std::array<uint, 13> qt_protobuf_Sensor_uint_data;
    const char qt_protobuf_Sensor_char_data[29];
} qt_protobuf_Sensor_metadata {
    // data
    {
        0, /* = version */
        3, /* = num fields */
        4, /* = field number offset */
        7, /* = property index offset */
        10, /* = field flags offset */
        11, /* = message full name length */
    },
    // uint_data
    {
        // JSON name offsets:
        12, /* = iD */
        15, /* = value */
        21, /* = typeID */
        28, /* = end-of-string-marker */
        // Field numbers:
        1, /* = iD */
        2, /* = value */
        3, /* = typeID */
        // Property indices:
        0, /* = iD */
        1, /* = value */
        2, /* = typeID */
        // Field flags:
        uint(QtProtobufPrivate::FieldFlag::NoFlags), /* = iD */
        uint(QtProtobufPrivate::FieldFlag::NoFlags), /* = value */
        uint(QtProtobufPrivate::FieldFlag::NoFlags), /* = typeID */
    },
    // char_data
    /* metadata char_data: */
    "chat.Sensor\0" /* = full message name */
    /* field char_data: */
    "iD\0value\0typeID\0"
};

const QtProtobufPrivate::QProtobufPropertyOrdering Sensor::staticPropertyOrdering = {
    &qt_protobuf_Sensor_metadata.data
};

void Sensor::registerTypes()
{
    qRegisterMetaType<Sensor>();
    qRegisterMetaType<QList<Sensor>>();
}

Sensor::Sensor()
    : QProtobufMessage(&Sensor::staticMetaObject, &Sensor::staticPropertyOrdering),
      dptr(new Sensor_QtProtobufData)
{
}

Sensor::Sensor(const Sensor &other)
    = default;
Sensor &Sensor::operator =(const Sensor &other)
{
    Sensor temp(other);
    swap(temp);
    return *this;
}
Sensor::Sensor(Sensor &&other) noexcept
    = default;
Sensor::operator QVariant() const
{
    return QVariant::fromValue(*this);
}
bool comparesEqual(const Sensor &lhs, const Sensor &rhs) noexcept
{
    return operator ==(static_cast<const QProtobufMessage&>(lhs),
                       static_cast<const QProtobufMessage&>(rhs))
        && lhs.dptr->m_iD == rhs.dptr->m_iD
        && lhs.dptr->m_value == rhs.dptr->m_value
        && lhs.dptr->m_typeID == rhs.dptr->m_typeID;
}

const QString &Sensor::iD() const &
{
    return dptr->m_iD;
}

QtProtobuf::int64 Sensor::value() const
{
    return dptr->m_value;
}

QtProtobuf::int64 Sensor::typeID() const
{
    return dptr->m_typeID;
}

void Sensor::setID(const QString &iD)
{
    if (dptr->m_iD != iD) {
        dptr.detach();
        dptr->m_iD = iD;
    }
}

void Sensor::setID(QString &&iD)
{
    if (dptr->m_iD != iD) {
        dptr.detach();
        dptr->m_iD = std::move(iD);
    }
}

void Sensor::setValue(QtProtobuf::int64 value)
{
    if (dptr->m_value != value) {
        dptr.detach();
        dptr->m_value = value;
    }
}

void Sensor::setTypeID(QtProtobuf::int64 typeID)
{
    if (dptr->m_typeID != typeID) {
        dptr.detach();
        dptr->m_typeID = typeID;
    }
}


class Chat_QtProtobufData : public QSharedData
{
public:
    Chat_QtProtobufData()
        : QSharedData(),
          m_sensors(nullptr)
    {
    }

    Chat_QtProtobufData(const Chat_QtProtobufData &other)
        : QSharedData(other),
          m_sender(other.m_sender),
          m_sensors(other.m_sensors
                                               ? new Sensor(*other.m_sensors)
                                               : nullptr)
    {
    }

    QString m_sender;
    QtProtobufPrivate::QProtobufLazyMessagePointer<Sensor> m_sensors;
};

Chat::~Chat() = default;

static constexpr struct {
    QtProtobufPrivate::QProtobufPropertyOrdering::Data data;
    const std::array<uint, 9> qt_protobuf_Chat_uint_data;
    const char qt_protobuf_Chat_char_data[26];
} qt_protobuf_Chat_metadata {
    // data
    {
        0, /* = version */
        2, /* = num fields */
        3, /* = field number offset */
        5, /* = property index offset */
        7, /* = field flags offset */
        9, /* = message full name length */
    },
    // uint_data
    {
        // JSON name offsets:
        10, /* = sender */
        17, /* = sensors */
        25, /* = end-of-string-marker */
        // Field numbers:
        1, /* = sender */
        2, /* = sensors */
        // Property indices:
        0, /* = sender */
        1, /* = sensors */
        // Field flags:
        uint(QtProtobufPrivate::FieldFlag::NoFlags), /* = sender */
        uint(QtProtobufPrivate::FieldFlag::ExplicitPresence | QtProtobufPrivate::FieldFlag::Message), /* = sensors */
    },
    // char_data
    /* metadata char_data: */
    "chat.Chat\0" /* = full message name */
    /* field char_data: */
    "sender\0sensors\0"
};

const QtProtobufPrivate::QProtobufPropertyOrdering Chat::staticPropertyOrdering = {
    &qt_protobuf_Chat_metadata.data
};

void Chat::registerTypes()
{
    qRegisterMetaType<Chat>();
    qRegisterMetaType<QList<Chat>>();
}

Chat::Chat()
    : QProtobufMessage(&Chat::staticMetaObject, &Chat::staticPropertyOrdering),
      dptr(new Chat_QtProtobufData)
{
}

Chat::Chat(const Chat &other)
    = default;
Chat &Chat::operator =(const Chat &other)
{
    Chat temp(other);
    swap(temp);
    return *this;
}
Chat::Chat(Chat &&other) noexcept
    = default;
Chat::operator QVariant() const
{
    return QVariant::fromValue(*this);
}
bool comparesEqual(const Chat &lhs, const Chat &rhs) noexcept
{
    return operator ==(static_cast<const QProtobufMessage&>(lhs),
                       static_cast<const QProtobufMessage&>(rhs))
        && lhs.dptr->m_sender == rhs.dptr->m_sender
        && (lhs.dptr->m_sensors == rhs.dptr->m_sensors
            || *lhs.dptr->m_sensors == *rhs.dptr->m_sensors);
}

const QString &Chat::sender() const &
{
    return dptr->m_sender;
}

Sensor *Chat::sensors_p()
{
    if (!dptr->m_sensors)
        dptr.detach();
    return dptr->m_sensors.get();
}

bool Chat::hasSensors() const
{
    return dptr->m_sensors.operator bool();
}

const Sensor &Chat::sensors() const &
{
    return *dptr->m_sensors;
}

void Chat::clearSensors()
{
    if (dptr->m_sensors) {
        dptr.detach();
        dptr->m_sensors.reset();
    }
}

void Chat::setSender(const QString &sender)
{
    if (dptr->m_sender != sender) {
        dptr.detach();
        dptr->m_sender = sender;
    }
}

void Chat::setSender(QString &&sender)
{
    if (dptr->m_sender != sender) {
        dptr.detach();
        dptr->m_sender = std::move(sender);
    }
}

void Chat::setSensors_p(Sensor *sensors)
{
    if (dptr->m_sensors.get() != sensors) {
        dptr.detach();
        dptr->m_sensors.reset(sensors);
    }
}

void Chat::setSensors(const Sensor &sensors)
{
    if (*dptr->m_sensors != sensors) {
        dptr.detach();
        *dptr->m_sensors = sensors;
    }
}

void Chat::setSensors(Sensor &&sensors)
{
    if (*dptr->m_sensors != sensors) {
        dptr.detach();
        *dptr->m_sensors = std::move(sensors);
    }
}


class Wrapper_QtProtobufData : public QSharedData
{
public:
    Wrapper_QtProtobufData()
        : QSharedData()
    {
    }

    Wrapper_QtProtobufData(const Wrapper_QtProtobufData &other)
        : QSharedData(other),
          m_payload(other.m_payload)
    {
    }

    QtProtobufPrivate::QProtobufOneof m_payload;
};

Wrapper::~Wrapper() = default;

static constexpr struct {
    QtProtobufPrivate::QProtobufPropertyOrdering::Data data;
    const std::array<uint, 9> qt_protobuf_Wrapper_uint_data;
    const char qt_protobuf_Wrapper_char_data[25];
} qt_protobuf_Wrapper_metadata {
    // data
    {
        0, /* = version */
        2, /* = num fields */
        3, /* = field number offset */
        5, /* = property index offset */
        7, /* = field flags offset */
        12, /* = message full name length */
    },
    // uint_data
    {
        // JSON name offsets:
        13, /* = login */
        19, /* = chat */
        24, /* = end-of-string-marker */
        // Field numbers:
        1, /* = login */
        2, /* = chat */
        // Property indices:
        0, /* = login */
        2, /* = chat */
        // Field flags:
        uint(QtProtobufPrivate::FieldFlag::Oneof | QtProtobufPrivate::FieldFlag::ExplicitPresence | QtProtobufPrivate::FieldFlag::Message), /* = login */
        uint(QtProtobufPrivate::FieldFlag::Oneof | QtProtobufPrivate::FieldFlag::ExplicitPresence | QtProtobufPrivate::FieldFlag::Message), /* = chat */
    },
    // char_data
    /* metadata char_data: */
    "chat.Wrapper\0" /* = full message name */
    /* field char_data: */
    "login\0chat\0"
};

const QtProtobufPrivate::QProtobufPropertyOrdering Wrapper::staticPropertyOrdering = {
    &qt_protobuf_Wrapper_metadata.data
};

void Wrapper::registerTypes()
{
    qRegisterMetaType<Wrapper>();
    qRegisterMetaType<QList<Wrapper>>();
}

Wrapper::Wrapper()
    : QProtobufMessage(&Wrapper::staticMetaObject, &Wrapper::staticPropertyOrdering),
      dptr(new Wrapper_QtProtobufData)
{
}

Wrapper::Wrapper(const Wrapper &other)
    = default;
Wrapper &Wrapper::operator =(const Wrapper &other)
{
    Wrapper temp(other);
    swap(temp);
    return *this;
}
Wrapper::Wrapper(Wrapper &&other) noexcept
    = default;
Wrapper::operator QVariant() const
{
    return QVariant::fromValue(*this);
}
bool comparesEqual(const Wrapper &lhs, const Wrapper &rhs) noexcept
{
    return operator ==(static_cast<const QProtobufMessage&>(lhs),
                       static_cast<const QProtobufMessage&>(rhs))
        && lhs.dptr->m_payload == rhs.dptr->m_payload;
}

Login *Wrapper::login_p()
{
    if (!dptr->m_payload.holdsField(1))
        dptr.detach();
    return dptr->m_payload.message<Login>();
}

bool Wrapper::hasLogin() const
{
    return dptr->m_payload.holdsField(1);
}
Login &Wrapper::login() const
{
    Q_ASSERT(dptr->m_payload.holdsField(1));
    return *(dptr->m_payload.message<Login>());
}

Chat *Wrapper::chat_p()
{
    if (!dptr->m_payload.holdsField(2))
        dptr.detach();
    return dptr->m_payload.message<Chat>();
}

bool Wrapper::hasChat() const
{
    return dptr->m_payload.holdsField(2);
}
Chat &Wrapper::chat() const
{
    Q_ASSERT(dptr->m_payload.holdsField(2));
    return *(dptr->m_payload.message<Chat>());
}

void Wrapper::setLogin(const Login &login)
{
    if (!dptr->m_payload.isEqual(login, 1)) {
        dptr.detach();
        dptr->m_payload.setValue(login, 1);
    }
}

void Wrapper::setLogin(Login &&login)
{
    if (!dptr->m_payload.isEqual(login, 1)) {
        dptr.detach();
        dptr->m_payload.setValue(std::move(login), 1);
    }
}

void Wrapper::setLogin_p(Login *login)
{
    const Login &value = *login;
    if (!dptr->m_payload.isEqual(value, 1)) {
        dptr.detach();
        dptr->m_payload.setValue(value, 1);
    }
}

void Wrapper::setChat(const Chat &chat)
{
    if (!dptr->m_payload.isEqual(chat, 2)) {
        dptr.detach();
        dptr->m_payload.setValue(chat, 2);
    }
}

void Wrapper::setChat(Chat &&chat)
{
    if (!dptr->m_payload.isEqual(chat, 2)) {
        dptr.detach();
        dptr->m_payload.setValue(std::move(chat), 2);
    }
}

void Wrapper::setChat_p(Chat *chat)
{
    const Chat &value = *chat;
    if (!dptr->m_payload.isEqual(value, 2)) {
        dptr.detach();
        dptr->m_payload.setValue(value, 2);
    }
}

Wrapper::PayloadFields Wrapper::payloadField() const
{
    return static_cast<PayloadFields>(dptr->m_payload.fieldNumber());
}
void Wrapper::clearPayload()
{
    if (dptr->m_payload.fieldNumber() != QtProtobuf::InvalidFieldNumber) {
        dptr.detach();
        dptr->m_payload = QtProtobufPrivate::QProtobufOneof();
    }
}
} // namespace chat

#include "moc_message.qpb.cpp"
